#include <stdio.h>

#define NIL 0

typedef struct Node {
  int value;
  struct Node* next;
  struct Node* child;
} Node;

typedef struct Graph {
  Node* node1;
  Node* node2;
  Node* node3;
  Node* node4;
  Node* node5;
  int count;
} Graph;

Node* create_node(int val)
{
    Node* n = new Node;
    n->value = val;
    n->next = NIL;
    n->child = NIL;
    return n;
}

void test_basic_collection()
{
    printf("=== Basic Collection Test ===\n");

    Node* temp1 = create_node(100);
    Node* temp2 = create_node(200);
    Node* temp3 = create_node(300);

    temp1->next = temp2;
    temp2->next = temp3;

    printf("Created temporary chain: %d -> %d -> %d\n",
            temp1->value, temp2->value, temp3->value);

    Node* keeper = create_node(999);
    printf("Created keeper node: %d\n", keeper->value);

    runtime_gc();
    printf("Chain still exists chain: %d -> %d -> %d\n",
            temp1->value, temp2->value, temp3->value);

    temp1 = NIL;
    temp2 = NIL;
    temp3 = NIL;

    printf("Temporary chain made unreachable\n");
    printf("Keeper still accessible: %d\n", keeper->value);

    runtime_gc();
    printf("Garbage collection completed\n");
}

void test_reachable_cycles()
{
    printf("\n=== Reachable Cycle Test ===\n");

    Node* a = create_node(1);
    Node* b = create_node(2);
    Node* c = create_node(3);

    // Create a cycle
    a->next = b;
    b->next = c;
    c->next = a;

    printf("Created cycle: %d -> %d -> %d -> (back to %d)\n",
            a->value, b->value, c->value, a->value);

    b = NIL;
    c = NIL;

    // As long as 'a' is reachable from stack, entire cycle stays alive
    printf("Cycle root value: %d\n", a->value);

    runtime_gc();
    printf("GC run - cycle should remain (still reachable)\n");
    printf("Cycle still accessible via a: %d\n", a->value);

    a = NIL;

    printf("Broke reference to cycle\n");
    runtime_gc();
    printf("GC run - cycle should be collected now\n");
}

void test_partial_structures()
{
    printf("\n=== Partial Structure Collection Test ===\n");

    Node* root = create_node(1);
    Node* branch1 = create_node(2);
    Node* branch2 = create_node(3);
    Node* leaf1 = create_node(4);
    Node* leaf2 = create_node(5);

    root->next = branch1;
    root->child = branch2;
    branch1->child = leaf1;
    branch2->child = leaf2;

    printf("Built tree: root(%d) -> branch1(%d) -> leaf1(%d)\n",
            root->value, branch1->value, leaf1->value);
    printf("           root(%d) -> branch2(%d) -> leaf2(%d)\n",
            root->value, branch2->value, leaf2->value);

    branch1 = NIL;
    branch2 = NIL;
    leaf1 = NIL;
    leaf2 = NIL;

    // Cut off branch2 subtree
    root->child = NIL;

    printf("Cut off branch2 subtree\n");
    runtime_gc();
    printf("GC should collect branch2(%d) and leaf2(%d)\n", 2, 5);
    printf("Root and branch1 subtree still reachable: %d -> %d -> %d\n",
            root->value, root->next->value, root->next->child->value);
}

void test_gc_threshold()
{
    printf("\n=== GC Threshold Test ===\n");

    // Set a low threshold to trigger frequent collections
    runtime_set_gc_threshold(1024);

    printf("Set GC threshold to 1KB\n");

    Node* keeper = create_node(42);
    printf("Created keeper: %d\n", keeper->value);

    // Allocate and abandon many nodes to trigger GC
    int i = 0;
    while (i<50) {
        Node* temp = create_node(i);
        i = i+1;
    }

    printf("Allocated and abandoned 50 temporary nodes\n");
    printf("Keeper should still be alive: %d\n", keeper->value);

    runtime_gc();
    printf("Final GC completed\n");
}

//void demonstrate_conservative_scanning()
//{
//    printf("\n=== Conservative Stack Scanning Demo ===\n");
//
//    // Create node and store pointer in local variable
//    Node* local_ptr = create_node(777);
//    printf("Created node with local pointer: %d\n", local_ptr->value);
//
//    // Create some stack noise (other local variables)
//    int dummy1 = 111;
//    int dummy2 = 222;
//    char buffer[64] = "stack data";
//
//    printf("Added stack noise: %d, %d, %s\n", dummy1, dummy2, buffer);
//
//    // The conservative scanner should find local_ptr on the stack
//    runtime_gc();
//    printf("GC completed - node should survive (found via stack scan)\n");
//    printf("Node still accessible: %d\n", local_ptr->value);
//
//    // Clear the pointer
//    local_ptr = NIL;
//
//    printf("Cleared local pointer\n");
//    runtime_gc();
//    printf("GC completed - node should be collected now\n");
//}

int main()
{
    printf("Mark-Sweep Garbage Collector Test Program\n");
    printf("=========================================\n");

    test_basic_collection();
    test_reachable_cycles();
    test_partial_structures();
    test_gc_threshold();
//    demonstrate_conservative_scanning();

    printf("\n=== All Tests Complete ===\n");
    return 0;
}